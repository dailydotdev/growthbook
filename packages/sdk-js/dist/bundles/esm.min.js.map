{"version":3,"file":"esm.min.js","sources":["../../src/util.ts","../../src/mongrule.ts","../../src/GrowthBook.ts"],"sourcesContent":["import { UrlTarget, UrlTargetType, VariationRange } from \"./types/growthbook\";\n\nfunction hashFnv32a(str: string): number {\n  let hval = 0x811c9dc5;\n  const l = str.length;\n\n  for (let i = 0; i < l; i++) {\n    hval ^= str.charCodeAt(i);\n    hval +=\n      (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);\n  }\n  return hval >>> 0;\n}\n\nexport function hash(\n  seed: string,\n  value: string,\n  version: number\n): number | null {\n  // New unbiased hashing algorithm\n  if (version === 2) {\n    return (hashFnv32a(hashFnv32a(seed + value) + \"\") % 10000) / 10000;\n  }\n  // Original biased hashing algorithm (keep for backwards compatibility)\n  if (version === 1) {\n    return (hashFnv32a(value + seed) % 1000) / 1000;\n  }\n\n  // Unknown hash version\n  return null;\n}\n\nexport function getEqualWeights(n: number): number[] {\n  if (n <= 0) return [];\n  return new Array(n).fill(1 / n);\n}\n\nexport function inRange(n: number, range: VariationRange): boolean {\n  return n >= range[0] && n < range[1];\n}\n\nexport function inNamespace(\n  hashValue: string,\n  namespace: [string, number, number]\n): boolean {\n  const n = hash(\"__\" + namespace[0], hashValue, 1);\n  if (n === null) return false;\n  return n >= namespace[1] && n < namespace[2];\n}\n\nexport function chooseVariation(n: number, ranges: VariationRange[]): number {\n  for (let i = 0; i < ranges.length; i++) {\n    if (inRange(n, ranges[i])) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nexport function getUrlRegExp(regexString: string): RegExp | undefined {\n  try {\n    const escaped = regexString.replace(/([^\\\\])\\//g, \"$1\\\\/\");\n    return new RegExp(escaped);\n  } catch (e) {\n    console.error(e);\n    return undefined;\n  }\n}\n\nexport function isURLTargeted(url: string, targets: UrlTarget[]) {\n  if (!targets.length) return false;\n  let hasIncludeRules = false;\n  let isIncluded = false;\n\n  for (let i = 0; i < targets.length; i++) {\n    const match = _evalURLTarget(url, targets[i].type, targets[i].pattern);\n    if (targets[i].include === false) {\n      if (match) return false;\n    } else {\n      hasIncludeRules = true;\n      if (match) isIncluded = true;\n    }\n  }\n\n  return isIncluded || !hasIncludeRules;\n}\n\nfunction _evalSimpleUrlPart(\n  actual: string,\n  pattern: string,\n  isPath: boolean\n): boolean {\n  try {\n    // Escape special regex characters and change wildcard `_____` to `.*`\n    let escaped = pattern\n      .replace(/[*.+?^${}()|[\\]\\\\]/g, \"\\\\$&\")\n      .replace(/_____/g, \".*\");\n\n    if (isPath) {\n      // When matching pathname, make leading/trailing slashes optional\n      escaped = \"\\\\/?\" + escaped.replace(/(^\\/|\\/$)/g, \"\") + \"\\\\/?\";\n    }\n\n    const regex = new RegExp(\"^\" + escaped + \"$\", \"i\");\n    return regex.test(actual);\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _evalSimpleUrlTarget(actual: URL, pattern: string) {\n  try {\n    // If a protocol is missing, but a host is specified, add `https://` to the front\n    // Use \"_____\" as the wildcard since `*` is not a valid hostname in some browsers\n    const expected = new URL(\n      pattern.replace(/^([^:/?]*)\\./i, \"https://$1.\").replace(/\\*/g, \"_____\"),\n      \"https://_____\"\n    );\n\n    // Compare each part of the URL separately\n    const comps: Array<[string, string, boolean]> = [\n      [actual.host, expected.host, false],\n      [actual.pathname, expected.pathname, true],\n    ];\n    // We only want to compare hashes if it's explicitly being targeted\n    if (expected.hash) {\n      comps.push([actual.hash, expected.hash, false]);\n    }\n\n    expected.searchParams.forEach((v, k) => {\n      comps.push([actual.searchParams.get(k) || \"\", v, false]);\n    });\n\n    // If any comparisons fail, the whole thing fails\n    return !comps.some(\n      (data) => !_evalSimpleUrlPart(data[0], data[1], data[2])\n    );\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _evalURLTarget(\n  url: string,\n  type: UrlTargetType,\n  pattern: string\n): boolean {\n  try {\n    const parsed = new URL(url, \"https://_\");\n\n    if (type === \"regex\") {\n      const regex = getUrlRegExp(pattern);\n      if (!regex) return false;\n      return (\n        regex.test(parsed.href) ||\n        regex.test(parsed.href.substring(parsed.origin.length))\n      );\n    } else if (type === \"simple\") {\n      return _evalSimpleUrlTarget(parsed, pattern);\n    }\n\n    return false;\n  } catch (e) {\n    return false;\n  }\n}\n\nexport function getBucketRanges(\n  numVariations: number,\n  coverage: number | undefined,\n  weights?: number[]\n): VariationRange[] {\n  coverage = coverage === undefined ? 1 : coverage;\n\n  // Make sure coverage is within bounds\n  if (coverage < 0) {\n    if (process.env.NODE_ENV !== \"production\") {\n      console.error(\"Experiment.coverage must be greater than or equal to 0\");\n    }\n    coverage = 0;\n  } else if (coverage > 1) {\n    if (process.env.NODE_ENV !== \"production\") {\n      console.error(\"Experiment.coverage must be less than or equal to 1\");\n    }\n    coverage = 1;\n  }\n\n  // Default to equal weights if missing or invalid\n  const equal = getEqualWeights(numVariations);\n  weights = weights || equal;\n  if (weights.length !== numVariations) {\n    if (process.env.NODE_ENV !== \"production\") {\n      console.error(\n        \"Experiment.weights array must be the same length as Experiment.variations\"\n      );\n    }\n    weights = equal;\n  }\n\n  // If weights don't add up to 1 (or close to it), default to equal weights\n  const totalWeight = weights.reduce((w, sum) => sum + w, 0);\n  if (totalWeight < 0.99 || totalWeight > 1.01) {\n    if (process.env.NODE_ENV !== \"production\") {\n      console.error(\"Experiment.weights must add up to 1\");\n    }\n    weights = equal;\n  }\n\n  // Covert weights to ranges\n  let cumulative = 0;\n  return weights.map((w) => {\n    const start = cumulative;\n    cumulative += w;\n    return [start, start + (coverage as number) * w];\n  }) as VariationRange[];\n}\n\nexport function getQueryStringOverride(\n  id: string,\n  url: string,\n  numVariations: number\n) {\n  if (!url) {\n    return null;\n  }\n\n  const search = url.split(\"?\")[1];\n  if (!search) {\n    return null;\n  }\n\n  const match = search\n    .replace(/#.*/, \"\") // Get rid of anchor\n    .split(\"&\") // Split into key/value pairs\n    .map((kv) => kv.split(\"=\", 2))\n    .filter(([k]) => k === id) // Look for key that matches the experiment id\n    .map(([, v]) => parseInt(v)); // Parse the value into an integer\n\n  if (match.length > 0 && match[0] >= 0 && match[0] < numVariations)\n    return match[0];\n\n  return null;\n}\n\nexport function isIncluded(include: () => boolean) {\n  try {\n    return include();\n  } catch (e) {\n    console.error(e);\n    return false;\n  }\n}\n\nconst base64ToBuf = (b: string) =>\n  Uint8Array.from(atob(b), (c) => c.charCodeAt(0));\n\nexport async function decrypt(\n  encryptedString: string,\n  decryptionKey?: string,\n  subtle?: SubtleCrypto\n): Promise<string> {\n  decryptionKey = decryptionKey || \"\";\n  subtle = subtle || (globalThis.crypto && globalThis.crypto.subtle);\n  if (!subtle) {\n    throw new Error(\"No SubtleCrypto implementation found\");\n  }\n  try {\n    const key = await subtle.importKey(\n      \"raw\",\n      base64ToBuf(decryptionKey),\n      { name: \"AES-CBC\", length: 128 },\n      true,\n      [\"encrypt\", \"decrypt\"]\n    );\n    const [iv, cipherText] = encryptedString.split(\".\");\n    const plainTextBuffer = await subtle.decrypt(\n      { name: \"AES-CBC\", iv: base64ToBuf(iv) },\n      key,\n      base64ToBuf(cipherText)\n    );\n\n    return new TextDecoder().decode(plainTextBuffer);\n  } catch (e) {\n    throw new Error(\"Failed to decrypt\");\n  }\n}\n\nexport function paddedVersionString(input: string): string {\n  // Remove build info and leading `v` if any\n  // Split version into parts (both core version numbers and pre-release tags)\n  // \"v1.2.3-rc.1+build123\" -> [\"1\",\"2\",\"3\",\"rc\",\"1\"]\n  const parts = input.replace(/(^v|\\+.*$)/g, \"\").split(/[-.]/);\n\n  // If it's SemVer without a pre-release, add `~` to the end\n  // [\"1\",\"0\",\"0\"] -> [\"1\",\"0\",\"0\",\"~\"]\n  // \"~\" is the largest ASCII character, so this will make \"1.0.0\" greater than \"1.0.0-beta\" for example\n  if (parts.length === 3) {\n    parts.push(\"~\");\n  }\n\n  // Left pad each numeric part with spaces so string comparisons will work (\"9\">\"10\", but \" 9\"<\"10\")\n  // Then, join back together into a single string\n  return parts\n    .map((v) => (v.match(/^[0-9]+$/) ? v.padStart(5, \" \") : v))\n    .join(\"-\");\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport {\n  ConditionInterface,\n  TestedObj,\n  ConditionValue,\n  Operator,\n  OperatorConditionValue,\n  VarType,\n} from \"./types/mongrule\";\nimport { paddedVersionString } from \"./util\";\n\nconst _regexCache: { [key: string]: RegExp } = {};\n\n// The top-level condition evaluation function\nexport function evalCondition(\n  obj: TestedObj,\n  condition: ConditionInterface\n): boolean {\n  // Recursive condition\n  if (\"$or\" in condition) {\n    return evalOr(obj, condition[\"$or\"] as ConditionInterface[]);\n  }\n  if (\"$nor\" in condition) {\n    return !evalOr(obj, condition[\"$nor\"] as ConditionInterface[]);\n  }\n  if (\"$and\" in condition) {\n    return evalAnd(obj, condition[\"$and\"] as ConditionInterface[]);\n  }\n  if (\"$not\" in condition) {\n    return !evalCondition(obj, condition[\"$not\"] as ConditionInterface);\n  }\n\n  // Condition is an object, keys are object paths, values are the condition for that path\n  for (const [k, v] of Object.entries(condition)) {\n    if (!evalConditionValue(v, getPath(obj, k))) return false;\n  }\n  return true;\n}\n\n// Return value at dot-separated path of an object\nfunction getPath(obj: TestedObj, path: string) {\n  const parts = path.split(\".\");\n  let current: any = obj;\n  for (let i = 0; i < parts.length; i++) {\n    if (current && typeof current === \"object\" && parts[i] in current) {\n      current = current[parts[i]];\n    } else {\n      return null;\n    }\n  }\n  return current;\n}\n\n// Transform a regex string into a real RegExp object\nfunction getRegex(regex: string): RegExp {\n  if (!_regexCache[regex]) {\n    _regexCache[regex] = new RegExp(regex.replace(/([^\\\\])\\//g, \"$1\\\\/\"));\n  }\n  return _regexCache[regex];\n}\n\n// Evaluate a single value against a condition\nfunction evalConditionValue(condition: ConditionValue, value: any) {\n  // Simple equality comparisons\n  if (typeof condition === \"string\") {\n    return value + \"\" === condition;\n  }\n  if (typeof condition === \"number\") {\n    return value * 1 === condition;\n  }\n  if (typeof condition === \"boolean\") {\n    return !!value === condition;\n  }\n\n  if (condition === null) {\n    return value === null;\n  }\n\n  if (Array.isArray(condition) || !isOperatorObject(condition)) {\n    return JSON.stringify(value) === JSON.stringify(condition);\n  }\n\n  // This is a special operator condition and we should evaluate each one separately\n  for (const op in condition) {\n    if (\n      !evalOperatorCondition(\n        op as Operator,\n        value,\n        condition[op as keyof OperatorConditionValue]\n      )\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// If the object has only keys that start with '$'\nfunction isOperatorObject(obj: any): boolean {\n  const keys = Object.keys(obj);\n  return (\n    keys.length > 0 && keys.filter((k) => k[0] === \"$\").length === keys.length\n  );\n}\n\n// Return the data type of a value\nfunction getType(v: any): VarType | \"unknown\" {\n  if (v === null) return \"null\";\n  if (Array.isArray(v)) return \"array\";\n  const t = typeof v;\n  if ([\"string\", \"number\", \"boolean\", \"object\", \"undefined\"].includes(t)) {\n    return t as VarType;\n  }\n  return \"unknown\";\n}\n\n// At least one element of actual must match the expected condition/value\nfunction elemMatch(actual: any, expected: any) {\n  if (!Array.isArray(actual)) return false;\n  const check = isOperatorObject(expected)\n    ? (v: any) => evalConditionValue(expected, v)\n    : (v: any) => evalCondition(v, expected);\n  for (let i = 0; i < actual.length; i++) {\n    if (actual[i] && check(actual[i])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction isIn(actual: any, expected: Array<any>): boolean {\n  // Do an intersection is attribute is an array\n  if (Array.isArray(actual)) {\n    return actual.some((el) => expected.includes(el));\n  }\n  return expected.includes(actual);\n}\n\n// Evaluate a single operator condition\nfunction evalOperatorCondition(\n  operator: Operator,\n  actual: any,\n  expected: any\n): boolean {\n  switch (operator) {\n    case \"$veq\":\n      return paddedVersionString(actual) === paddedVersionString(expected);\n    case \"$vne\":\n      return paddedVersionString(actual) !== paddedVersionString(expected);\n    case \"$vgt\":\n      return paddedVersionString(actual) > paddedVersionString(expected);\n    case \"$vgte\":\n      return paddedVersionString(actual) >= paddedVersionString(expected);\n    case \"$vlt\":\n      return paddedVersionString(actual) < paddedVersionString(expected);\n    case \"$vlte\":\n      return paddedVersionString(actual) <= paddedVersionString(expected);\n    case \"$eq\":\n      return actual === expected;\n    case \"$ne\":\n      return actual !== expected;\n    case \"$lt\":\n      return actual < expected;\n    case \"$lte\":\n      return actual <= expected;\n    case \"$gt\":\n      return actual > expected;\n    case \"$gte\":\n      return actual >= expected;\n    case \"$exists\":\n      return expected ? actual !== null : actual === null;\n    case \"$in\":\n      if (!Array.isArray(expected)) return false;\n      return isIn(actual, expected);\n    case \"$nin\":\n      if (!Array.isArray(expected)) return false;\n      return !isIn(actual, expected);\n    case \"$not\":\n      return !evalConditionValue(expected, actual);\n    case \"$size\":\n      if (!Array.isArray(actual)) return false;\n      return evalConditionValue(expected, actual.length);\n    case \"$elemMatch\":\n      return elemMatch(actual, expected);\n    case \"$all\":\n      if (!Array.isArray(actual)) return false;\n      for (let i = 0; i < expected.length; i++) {\n        let passed = false;\n        for (let j = 0; j < actual.length; j++) {\n          if (evalConditionValue(expected[i], actual[j])) {\n            passed = true;\n            break;\n          }\n        }\n        if (!passed) return false;\n      }\n      return true;\n    case \"$regex\":\n      try {\n        return getRegex(expected).test(actual);\n      } catch (e) {\n        return false;\n      }\n    case \"$type\":\n      return getType(actual) === expected;\n    default:\n      console.error(\"Unknown operator: \" + operator);\n      return false;\n  }\n}\n\n// Recursive $or rule\nfunction evalOr(obj: TestedObj, conditions: ConditionInterface[]): boolean {\n  if (!conditions.length) return true;\n  for (let i = 0; i < conditions.length; i++) {\n    if (evalCondition(obj, conditions[i])) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// Recursive $and rule\nfunction evalAnd(obj: TestedObj, conditions: ConditionInterface[]): boolean {\n  for (let i = 0; i < conditions.length; i++) {\n    if (!evalCondition(obj, conditions[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n","import type {\n  Context,\n  Experiment,\n  FeatureResult,\n  Result,\n  SubscriptionFunction,\n  FeatureDefinition,\n  FeatureResultSource,\n  Attributes,\n  WidenPrimitives,\n  ApiHost,\n  ClientKey,\n  VariationMeta,\n  Filter,\n  VariationRange,\n} from \"./types/growthbook\";\nimport type { ConditionInterface } from \"./types/mongrule\";\nimport {\n  getUrlRegExp,\n  isIncluded,\n  getBucketRanges,\n  hash,\n  chooseVariation,\n  getQueryStringOverride,\n  inNamespace,\n  inRange,\n  isURLTargeted,\n} from \"./util\";\nimport { evalCondition } from \"./mongrule\";\n\nconst isBrowser =\n  typeof window !== \"undefined\" && typeof document !== \"undefined\";\n\nexport class GrowthBook<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  AppFeatures extends Record<string, any> = Record<string, any>\n> {\n  // context is technically private, but some tools depend on it so we can't mangle the name\n  // _ctx below is a clone of this property that we use internally\n  private context: Context;\n  public debug: boolean;\n  public ready: boolean;\n\n  // Properties and methods that start with \"_\" are mangled by Terser (saves ~150 bytes)\n  private _ctx: Context;\n  private _renderer: null | (() => void);\n  private _trackedExperiments: Set<unknown>;\n  private _trackedFeatures: Record<string, string>;\n  private _subscriptions: Set<SubscriptionFunction>;\n  private _assigned: Map<\n    string,\n    {\n      // eslint-disable-next-line\n      experiment: Experiment<any>;\n      // eslint-disable-next-line\n      result: Result<any>;\n    }\n  >;\n  // eslint-disable-next-line\n  private _forcedFeatureValues: Map<string, any>;\n  private _attributeOverrides: Attributes;\n  private _activeAutoExperiments: Map<\n    string,\n    { valueHash: string; undo: () => void }\n  >;\n\n  constructor(context?: Context) {\n    context = context || {};\n    // These properties are all initialized in the constructor instead of above\n    // This saves ~80 bytes in the final output\n    this._ctx = this.context = context;\n    this._renderer = null;\n    this._trackedExperiments = new Set();\n    this._trackedFeatures = {};\n    this.debug = false;\n    this._subscriptions = new Set();\n    this.ready = false;\n    this._assigned = new Map();\n    this._forcedFeatureValues = new Map();\n    this._attributeOverrides = {};\n    this._activeAutoExperiments = new Map();\n\n    if (context.features) {\n      this.ready = true;\n    }\n\n    if (isBrowser && context.enableDevMode) {\n      window._growthbook = this;\n      document.dispatchEvent(new Event(\"gbloaded\"));\n    }\n\n    if (context.experiments) {\n      this.ready = true;\n    }\n  }\n\n  public getApiInfo(): [ApiHost, ClientKey] {\n    return [\n      (this._ctx.apiHost || \"https://cdn.growthbook.io\").replace(/\\/*$/, \"\"),\n      this._ctx.clientKey || \"\",\n    ];\n  }\n\n  private _render() {\n    if (this._renderer) {\n      this._renderer();\n    }\n  }\n\n  public setFeatures(features: Record<string, FeatureDefinition>) {\n    this._ctx.features = features;\n    this.ready = true;\n    this._render();\n  }\n\n  public setAttributes(attributes: Attributes) {\n    this._ctx.attributes = attributes;\n    this._render();\n  }\n\n  public setAttributeOverrides(overrides: Attributes) {\n    this._attributeOverrides = overrides;\n    this._render();\n  }\n  public setForcedVariations(vars: Record<string, number>) {\n    this._ctx.forcedVariations = vars || {};\n    this._render();\n  }\n  // eslint-disable-next-line\n  public setForcedFeatures(map: Map<string, any>) {\n    this._forcedFeatureValues = map;\n    this._render();\n  }\n\n  public setURL(url: string) {\n    this._ctx.url = url;\n  }\n\n  public getAttributes() {\n    return { ...this._ctx.attributes, ...this._attributeOverrides };\n  }\n\n  public getFeatures() {\n    return this._ctx.features || {};\n  }\n\n  public getExperiments() {\n    return this._ctx.experiments || [];\n  }\n\n  public subscribe(cb: SubscriptionFunction): () => void {\n    this._subscriptions.add(cb);\n\n    return () => {\n      this._subscriptions.delete(cb);\n    };\n  }\n\n  public getAllResults() {\n    return new Map(this._assigned);\n  }\n\n  public destroy() {\n    // Release references to save memory\n    this._subscriptions.clear();\n    this._assigned.clear();\n    this._trackedExperiments.clear();\n    this._trackedFeatures = {};\n\n    if (isBrowser && window._growthbook === this) {\n      delete window._growthbook;\n    }\n\n    // Undo any active auto experiments\n    this._activeAutoExperiments.forEach((exp) => {\n      exp.undo();\n    });\n    this._activeAutoExperiments.clear();\n  }\n\n  public setRenderer(renderer: () => void) {\n    this._renderer = renderer;\n  }\n\n  public forceVariation(key: string, variation: number) {\n    this._ctx.forcedVariations = this._ctx.forcedVariations || {};\n    this._ctx.forcedVariations[key] = variation;\n    this._render();\n  }\n\n  public run<T>(experiment: Experiment<T>): Result<T> {\n    const result = this._run(experiment, null);\n    this._fireSubscriptions(experiment, result);\n    return result;\n  }\n\n  private _fireSubscriptions<T>(experiment: Experiment<T>, result: Result<T>) {\n    const key = experiment.key;\n\n    // If assigned variation has changed, fire subscriptions\n    const prev = this._assigned.get(key);\n    // TODO: what if the experiment definition has changed?\n    if (\n      !prev ||\n      prev.result.inExperiment !== result.inExperiment ||\n      prev.result.variationId !== result.variationId\n    ) {\n      this._assigned.set(key, { experiment, result });\n      this._subscriptions.forEach((cb) => {\n        try {\n          cb(experiment, result);\n        } catch (e) {\n          console.error(e);\n        }\n      });\n    }\n  }\n\n  private _trackFeatureUsage(key: string, res: FeatureResult): void {\n    // Don't track feature usage that was forced via an override\n    if (res.source === \"override\") return;\n\n    // Only track a feature once, unless the assigned value changed\n    const stringifiedValue = JSON.stringify(res.value);\n    if (this._trackedFeatures[key] === stringifiedValue) return;\n    this._trackedFeatures[key] = stringifiedValue;\n\n    // Fire user-supplied callback\n    if (this._ctx.onFeatureUsage) {\n      try {\n        this._ctx.onFeatureUsage(key, res);\n      } catch (e) {\n        // Ignore feature usage callback errors\n      }\n    }\n\n    // In browser environments, queue up feature usage to be tracked in batches\n    if (!isBrowser || !window.fetch) return;\n  }\n\n  private _getFeatureResult<T>(\n    key: string,\n    value: T,\n    source: FeatureResultSource,\n    ruleId?: string,\n    experiment?: Experiment<T>,\n    result?: Result<T>\n  ): FeatureResult<T> {\n    const ret: FeatureResult = {\n      value,\n      on: !!value,\n      off: !value,\n      source,\n      ruleId: ruleId || \"\",\n    };\n    if (experiment) ret.experiment = experiment;\n    if (result) ret.experimentResult = result;\n\n    // Track the usage of this feature in real-time\n    this._trackFeatureUsage(key, ret);\n\n    return ret;\n  }\n\n  public isOn<K extends string & keyof AppFeatures = string>(key: K): boolean {\n    return this.evalFeature(key).on;\n  }\n\n  public isOff<K extends string & keyof AppFeatures = string>(key: K): boolean {\n    return this.evalFeature(key).off;\n  }\n\n  public getFeatureValue<\n    V extends AppFeatures[K],\n    K extends string & keyof AppFeatures = string\n  >(key: K, defaultValue: V): WidenPrimitives<V> {\n    const value = this.evalFeature<WidenPrimitives<V>, K>(key).value;\n    return value === null ? (defaultValue as WidenPrimitives<V>) : value;\n  }\n\n  /**\n   * @deprecated Use {@link evalFeature}\n   * @param id\n   */\n  // eslint-disable-next-line\n  public feature<\n    V extends AppFeatures[K],\n    K extends string & keyof AppFeatures = string\n  >(id: K): FeatureResult<V | null> {\n    return this.evalFeature(id);\n  }\n\n  public evalFeature<\n    V extends AppFeatures[K],\n    K extends string & keyof AppFeatures = string\n  >(id: K): FeatureResult<V | null> {\n    // Global override\n    if (this._forcedFeatureValues.has(id)) {\n      process.env.NODE_ENV !== \"production\" &&\n        this.log(\"Global override\", {\n          id,\n          value: this._forcedFeatureValues.get(id),\n        });\n      return this._getFeatureResult(\n        id,\n        this._forcedFeatureValues.get(id),\n        \"override\"\n      );\n    }\n\n    // Unknown feature id\n    if (!this._ctx.features || !this._ctx.features[id]) {\n      process.env.NODE_ENV !== \"production\" &&\n        this.log(\"Unknown feature\", { id });\n      return this._getFeatureResult(id, null, \"unknownFeature\");\n    }\n\n    // Get the feature\n    const feature: FeatureDefinition<V> = this._ctx.features[id];\n\n    // Loop through the rules\n    if (feature.rules) {\n      for (const rule of feature.rules) {\n        // If it's a conditional rule, skip if the condition doesn't pass\n        if (rule.condition && !this._conditionPasses(rule.condition)) {\n          process.env.NODE_ENV !== \"production\" &&\n            this.log(\"Skip rule because of condition\", {\n              id,\n              rule,\n            });\n          continue;\n        }\n        // If there are filters for who is included (e.g. namespaces)\n        if (rule.filters && this._isFilteredOut(rule.filters)) {\n          process.env.NODE_ENV !== \"production\" &&\n            this.log(\"Skip rule because of filters\", {\n              id,\n              rule,\n            });\n          continue;\n        }\n\n        // Feature value is being forced\n        if (\"force\" in rule) {\n          // If this is a percentage rollout, skip if not included\n          if (\n            !this._isIncludedInRollout(\n              rule.seed || id,\n              rule.hashAttribute,\n              rule.range,\n              rule.coverage,\n              rule.hashVersion\n            )\n          ) {\n            process.env.NODE_ENV !== \"production\" &&\n              this.log(\"Skip rule because user not included in rollout\", {\n                id,\n                rule,\n              });\n            continue;\n          }\n\n          process.env.NODE_ENV !== \"production\" &&\n            this.log(\"Force value from rule\", {\n              id,\n              rule,\n            });\n\n          // If this was a remotely evaluated experiment, fire the tracking callbacks\n          if (rule.tracks) {\n            rule.tracks.forEach((t) => {\n              this._track(t.experiment, t.result);\n            });\n          }\n\n          return this._getFeatureResult(id, rule.force as V, \"force\", rule.id);\n        }\n        if (!rule.variations) {\n          process.env.NODE_ENV !== \"production\" &&\n            this.log(\"Skip invalid rule\", {\n              id,\n              rule,\n            });\n\n          continue;\n        }\n        // For experiment rules, run an experiment\n        const exp: Experiment<V> = {\n          variations: rule.variations as [V, V, ...V[]],\n          key: rule.key || id,\n        };\n        if (\"coverage\" in rule) exp.coverage = rule.coverage;\n        if (rule.weights) exp.weights = rule.weights;\n        if (rule.hashAttribute) exp.hashAttribute = rule.hashAttribute;\n        if (rule.namespace) exp.namespace = rule.namespace;\n        if (rule.meta) exp.meta = rule.meta;\n        if (rule.ranges) exp.ranges = rule.ranges;\n        if (rule.name) exp.name = rule.name;\n        if (rule.phase) exp.phase = rule.phase;\n        if (rule.seed) exp.seed = rule.seed;\n        if (rule.hashVersion) exp.hashVersion = rule.hashVersion;\n        if (rule.filters) exp.filters = rule.filters;\n\n        // Only return a value if the user is part of the experiment\n        const res = this._run(exp, id);\n        this._fireSubscriptions(exp, res);\n        if (res.inExperiment && !res.passthrough) {\n          return this._getFeatureResult(\n            id,\n            res.value,\n            \"experiment\",\n            rule.id,\n            exp,\n            res\n          );\n        }\n      }\n    }\n\n    process.env.NODE_ENV !== \"production\" &&\n      this.log(\"Use default value\", {\n        id,\n        value: feature.defaultValue,\n      });\n\n    // Fall back to using the default value\n    return this._getFeatureResult(\n      id,\n      feature.defaultValue === undefined ? null : feature.defaultValue,\n      \"defaultValue\"\n    );\n  }\n\n  private _isIncludedInRollout(\n    seed: string,\n    hashAttribute: string | undefined,\n    range: VariationRange | undefined,\n    coverage: number | undefined,\n    hashVersion: number | undefined\n  ): boolean {\n    if (!range && coverage === undefined) return true;\n\n    const { hashValue } = this._getHashAttribute(hashAttribute);\n    if (!hashValue) {\n      return false;\n    }\n\n    const n = hash(seed, hashValue, hashVersion || 1);\n    if (n === null) return false;\n\n    return range\n      ? inRange(n, range)\n      : coverage !== undefined\n      ? n <= coverage\n      : true;\n  }\n\n  private _conditionPasses(condition: ConditionInterface): boolean {\n    return evalCondition(this.getAttributes(), condition);\n  }\n\n  private _isFilteredOut(filters: Filter[]): boolean {\n    return filters.some((filter) => {\n      const { hashValue } = this._getHashAttribute(filter.attribute);\n      if (!hashValue) return true;\n      const n = hash(filter.seed, hashValue, filter.hashVersion || 2);\n      if (n === null) return true;\n      return !filter.ranges.some((r) => inRange(n, r));\n    });\n  }\n\n  private _run<T>(\n    experiment: Experiment<T>,\n    featureId: string | null\n  ): Result<T> {\n    const key = experiment.key;\n    const numVariations = experiment.variations.length;\n\n    // 1. If experiment has less than 2 variations, return immediately\n    if (numVariations < 2) {\n      process.env.NODE_ENV !== \"production\" &&\n        this.log(\"Invalid experiment\", { id: key });\n      return this._getResult(experiment, -1, false, featureId);\n    }\n\n    // 2. If the context is disabled, return immediately\n    if (this._ctx.enabled === false) {\n      process.env.NODE_ENV !== \"production\" &&\n        this.log(\"Context disabled\", { id: key });\n      return this._getResult(experiment, -1, false, featureId);\n    }\n\n    // 2.5. Merge in experiment overrides from the context\n    experiment = this._mergeOverrides(experiment);\n\n    // 3. If a variation is forced from a querystring, return the forced variation\n    const qsOverride = getQueryStringOverride(\n      key,\n      this._getContextUrl(),\n      numVariations\n    );\n    if (qsOverride !== null) {\n      process.env.NODE_ENV !== \"production\" &&\n        this.log(\"Force via querystring\", {\n          id: key,\n          variation: qsOverride,\n        });\n      return this._getResult(experiment, qsOverride, false, featureId);\n    }\n\n    // 4. If a variation is forced in the context, return the forced variation\n    if (this._ctx.forcedVariations && key in this._ctx.forcedVariations) {\n      const variation = this._ctx.forcedVariations[key];\n      process.env.NODE_ENV !== \"production\" &&\n        this.log(\"Force via dev tools\", {\n          id: key,\n          variation,\n        });\n      return this._getResult(experiment, variation, false, featureId);\n    }\n\n    // 5. Exclude if a draft experiment or not active\n    if (experiment.status === \"draft\" || experiment.active === false) {\n      process.env.NODE_ENV !== \"production\" &&\n        this.log(\"Skip because inactive\", {\n          id: key,\n        });\n      return this._getResult(experiment, -1, false, featureId);\n    }\n\n    // 6. Get the hash attribute and return if empty\n    const { hashValue } = this._getHashAttribute(experiment.hashAttribute);\n    if (!hashValue) {\n      process.env.NODE_ENV !== \"production\" &&\n        this.log(\"Skip because missing hashAttribute\", {\n          id: key,\n        });\n      return this._getResult(experiment, -1, false, featureId);\n    }\n\n    // 7. Exclude if user is filtered out (used to be called \"namespace\")\n    if (experiment.filters) {\n      if (this._isFilteredOut(experiment.filters)) {\n        process.env.NODE_ENV !== \"production\" &&\n          this.log(\"Skip because of filters\", {\n            id: key,\n          });\n        return this._getResult(experiment, -1, false, featureId);\n      }\n    } else if (\n      experiment.namespace &&\n      !inNamespace(hashValue, experiment.namespace)\n    ) {\n      process.env.NODE_ENV !== \"production\" &&\n        this.log(\"Skip because of namespace\", {\n          id: key,\n        });\n      return this._getResult(experiment, -1, false, featureId);\n    }\n\n    // 7.5. Exclude if experiment.include returns false or throws\n    if (experiment.include && !isIncluded(experiment.include)) {\n      process.env.NODE_ENV !== \"production\" &&\n        this.log(\"Skip because of include function\", {\n          id: key,\n        });\n      return this._getResult(experiment, -1, false, featureId);\n    }\n\n    // 8. Exclude if condition is false\n    if (experiment.condition && !this._conditionPasses(experiment.condition)) {\n      process.env.NODE_ENV !== \"production\" &&\n        this.log(\"Skip because of condition\", {\n          id: key,\n        });\n      return this._getResult(experiment, -1, false, featureId);\n    }\n\n    // 8.1. Exclude if user is not in a required group\n    if (\n      experiment.groups &&\n      !this._hasGroupOverlap(experiment.groups as string[])\n    ) {\n      process.env.NODE_ENV !== \"production\" &&\n        this.log(\"Skip because of groups\", {\n          id: key,\n        });\n      return this._getResult(experiment, -1, false, featureId);\n    }\n\n    // 8.2. Old style URL targeting\n    if (experiment.url && !this._urlIsValid(experiment.url as RegExp)) {\n      process.env.NODE_ENV !== \"production\" &&\n        this.log(\"Skip because of url\", {\n          id: key,\n        });\n      return this._getResult(experiment, -1, false, featureId);\n    }\n\n    // 8.3. New, more powerful URL targeting\n    if (\n      experiment.urlPatterns &&\n      !isURLTargeted(this._getContextUrl(), experiment.urlPatterns)\n    ) {\n      process.env.NODE_ENV !== \"production\" &&\n        this.log(\"Skip because of url targeting\", {\n          id: key,\n        });\n      return this._getResult(experiment, -1, false, featureId);\n    }\n\n    // 9. Get bucket ranges and choose variation\n    const n = hash(\n      experiment.seed || key,\n      hashValue,\n      experiment.hashVersion || 1\n    );\n    if (n === null) {\n      process.env.NODE_ENV !== \"production\" &&\n        this.log(\"Skip because of invalid hash version\", {\n          id: key,\n        });\n      return this._getResult(experiment, -1, false, featureId);\n    }\n\n    const ranges =\n      experiment.ranges ||\n      getBucketRanges(\n        numVariations,\n        experiment.coverage === undefined ? 1 : experiment.coverage,\n        experiment.weights\n      );\n\n    const assigned = chooseVariation(n, ranges);\n\n    // 10. Return if not in experiment\n    if (assigned < 0) {\n      process.env.NODE_ENV !== \"production\" &&\n        this.log(\"Skip because of coverage\", {\n          id: key,\n        });\n      return this._getResult(experiment, -1, false, featureId);\n    }\n\n    // 11. Experiment has a forced variation\n    if (\"force\" in experiment) {\n      process.env.NODE_ENV !== \"production\" &&\n        this.log(\"Force variation\", {\n          id: key,\n          variation: experiment.force,\n        });\n      return this._getResult(\n        experiment,\n        experiment.force === undefined ? -1 : experiment.force,\n        false,\n        featureId\n      );\n    }\n\n    // 12. Exclude if in QA mode\n    if (this._ctx.qaMode) {\n      process.env.NODE_ENV !== \"production\" &&\n        this.log(\"Skip because QA mode\", {\n          id: key,\n        });\n      return this._getResult(experiment, -1, false, featureId);\n    }\n\n    // 12.5. Exclude if experiment is stopped\n    if (experiment.status === \"stopped\") {\n      process.env.NODE_ENV !== \"production\" &&\n        this.log(\"Skip because stopped\", {\n          id: key,\n        });\n      return this._getResult(experiment, -1, false, featureId);\n    }\n\n    // 13. Build the result object\n    const result = this._getResult(experiment, assigned, true, featureId, n);\n\n    // 14. Fire the tracking callback\n    this._track(experiment, result);\n\n    // 15. Return the result\n    process.env.NODE_ENV !== \"production\" &&\n      this.log(\"In experiment\", {\n        id: key,\n        variation: result.variationId,\n      });\n    return result;\n  }\n\n  log(msg: string, ctx: Record<string, unknown>) {\n    if (!this.debug) return;\n    if (this._ctx.log) this._ctx.log(msg, ctx);\n    else console.log(msg, ctx);\n  }\n\n  private _track<T>(experiment: Experiment<T>, result: Result<T>) {\n    if (!this._ctx.trackingCallback) return;\n\n    const key = experiment.key;\n\n    // Make sure a tracking callback is only fired once per unique experiment\n    const k =\n      result.hashAttribute + result.hashValue + key + result.variationId;\n    if (this._trackedExperiments.has(k)) return;\n    this._trackedExperiments.add(k);\n\n    try {\n      this._ctx.trackingCallback(experiment, result);\n    } catch (e) {\n      console.error(e);\n    }\n  }\n\n  private _mergeOverrides<T>(experiment: Experiment<T>): Experiment<T> {\n    const key = experiment.key;\n    const o = this._ctx.overrides;\n    if (o && o[key]) {\n      experiment = Object.assign({}, experiment, o[key]);\n      if (typeof experiment.url === \"string\") {\n        experiment.url = getUrlRegExp(\n          // eslint-disable-next-line\n          experiment.url as any\n        );\n      }\n    }\n\n    return experiment;\n  }\n\n  private _getHashAttribute(attr?: string) {\n    const hashAttribute = attr || \"id\";\n\n    let hashValue = \"\";\n    if (this._attributeOverrides[hashAttribute]) {\n      hashValue = this._attributeOverrides[hashAttribute];\n    } else if (this._ctx.attributes) {\n      hashValue = this._ctx.attributes[hashAttribute] || \"\";\n    } else if (this._ctx.user) {\n      hashValue = this._ctx.user[hashAttribute] || \"\";\n    }\n\n    return { hashAttribute, hashValue };\n  }\n\n  private _getResult<T>(\n    experiment: Experiment<T>,\n    variationIndex: number,\n    hashUsed: boolean,\n    featureId: string | null,\n    bucket?: number\n  ): Result<T> {\n    let inExperiment = true;\n    // If assigned variation is not valid, use the baseline and mark the user as not in the experiment\n    if (variationIndex < 0 || variationIndex >= experiment.variations.length) {\n      variationIndex = 0;\n      inExperiment = false;\n    }\n\n    const { hashAttribute, hashValue } = this._getHashAttribute(\n      experiment.hashAttribute\n    );\n\n    const meta: Partial<VariationMeta> = experiment.meta\n      ? experiment.meta[variationIndex]\n      : {};\n\n    const res: Result<T> = {\n      key: meta.key || \"\" + variationIndex,\n      featureId,\n      inExperiment,\n      hashUsed,\n      variationId: variationIndex,\n      value: experiment.variations[variationIndex],\n      hashAttribute,\n      hashValue,\n    };\n\n    if (meta.name) res.name = meta.name;\n    if (bucket !== undefined) res.bucket = bucket;\n    if (meta.passthrough) res.passthrough = meta.passthrough;\n\n    return res;\n  }\n\n  private _getContextUrl() {\n    return this._ctx.url || (isBrowser ? window.location.href : \"\");\n  }\n\n  private _urlIsValid(urlRegex: RegExp): boolean {\n    const url = this._getContextUrl();\n    if (!url) return false;\n\n    const pathOnly = url.replace(/^https?:\\/\\//, \"\").replace(/^[^/]*\\//, \"/\");\n\n    if (urlRegex.test(url)) return true;\n    if (urlRegex.test(pathOnly)) return true;\n    return false;\n  }\n\n  private _hasGroupOverlap(expGroups: string[]): boolean {\n    const groups = this._ctx.groups || {};\n    for (let i = 0; i < expGroups.length; i++) {\n      if (groups[expGroups[i]]) return true;\n    }\n    return false;\n  }\n}\n"],"names":["hashFnv32a","str","hval","l","length","i","charCodeAt","hash","seed","value","version","inRange","n","range","getUrlRegExp","regexString","escaped","replace","RegExp","e","console","error","isURLTargeted","url","targets","hasIncludeRules","isIncluded","match","_evalURLTarget","type","pattern","include","parsed","URL","regex","test","href","substring","origin","actual","expected","comps","host","pathname","push","searchParams","forEach","v","k","get","some","data","isPath","_evalSimpleUrlPart","_evalSimpleUrlTarget","paddedVersionString","input","parts","split","map","padStart","join","_regexCache","evalCondition","obj","condition","evalOr","conditions","evalAnd","Object","entries","evalConditionValue","getPath","path","current","Array","isArray","isOperatorObject","JSON","stringify","op","evalOperatorCondition","keys","filter","isIn","el","includes","operator","check","elemMatch","passed","j","t","getType","isBrowser","window","document","GrowthBook","constructor","context","this","_ctx","_renderer","_trackedExperiments","Set","_trackedFeatures","debug","_subscriptions","ready","_assigned","Map","_forcedFeatureValues","_attributeOverrides","_activeAutoExperiments","features","enableDevMode","_growthbook","dispatchEvent","Event","experiments","getApiInfo","apiHost","clientKey","_render","setFeatures","setAttributes","attributes","setAttributeOverrides","overrides","setForcedVariations","vars","forcedVariations","setForcedFeatures","setURL","getAttributes","getFeatures","getExperiments","subscribe","cb","add","delete","getAllResults","destroy","clear","exp","undo","setRenderer","renderer","forceVariation","key","variation","run","experiment","result","_run","_fireSubscriptions","prev","inExperiment","variationId","set","_trackFeatureUsage","res","source","stringifiedValue","onFeatureUsage","_getFeatureResult","ruleId","ret","on","off","experimentResult","isOn","evalFeature","isOff","getFeatureValue","defaultValue","feature","id","has","rules","rule","_conditionPasses","filters","_isFilteredOut","_isIncludedInRollout","hashAttribute","coverage","hashVersion","tracks","_track","force","variations","weights","namespace","meta","ranges","name","phase","passthrough","undefined","hashValue","_getHashAttribute","attribute","r","featureId","numVariations","_getResult","enabled","_mergeOverrides","qsOverride","search","kv","_ref","_ref2","parseInt","getQueryStringOverride","_getContextUrl","status","active","inNamespace","groups","_hasGroupOverlap","_urlIsValid","urlPatterns","assigned","chooseVariation","equal","fill","totalWeight","reduce","w","sum","cumulative","start","getBucketRanges","qaMode","log","msg","ctx","trackingCallback","o","assign","attr","user","variationIndex","hashUsed","bucket","location","urlRegex","pathOnly","expGroups"],"mappings":"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"}